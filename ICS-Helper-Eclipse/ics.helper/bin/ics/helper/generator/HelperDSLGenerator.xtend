/*
 * generated by Xtext 2.34.0
 */
package ics.helper.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import ics.helper.helperDSL.CreateCommand
import ics.helper.helperDSL.Event
import ics.helper.helperDSL.RecurRule
import java.text.SimpleDateFormat
import java.util.Date
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.ZoneId;
import java.time.format.DateTimeParseException;
import ics.helper.helperDSL.WEEKDAY
import ics.helper.helperDSL.Person

/**
 * Generates ICS files from your model files on save.
 */
class HelperDSLGenerator extends AbstractGenerator {
	private final DateTimeFormatter userInputFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
    private final DateTimeFormatter icsFormatter = DateTimeFormatter.ofPattern("yyyyMMdd'T'HHmmss'Z'").withZone(ZoneId.of("UTC"));

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        for (e : resource.allContents.toIterable.filter(CreateCommand)) {
            generateICSFile(e, fsa)
        }
    }

    def generateICSFile(CreateCommand command, IFileSystemAccess2 fsa) {
        val StringBuilder icsContent = new StringBuilder()
        icsContent.append("BEGIN:VCALENDAR\n")
        icsContent.append("VERSION:2.0\n")
        icsContent.append("PRODID:-//hacksw/handcal//NONSGML v1.0//EN\n")
        
        for (event : command.events) {
            icsContent.append("BEGIN:VEVENT\n")
            icsContent.append("SUMMARY:" + event.name + "\n")
            icsContent.append("DTSTART:" + convertToICSTimeFormat(event.startTime) + "\n")
            icsContent.append("DTEND:" + convertToICSTimeFormat(event.endTime) + "\n")
            if (event.location !== null) {
                icsContent.append("LOCATION:" + event.location + "\n")
            }
            if (event.description !== null) {
                icsContent.append("DESCRIPTION:" + event.description + "\n")
            }
            if (event.link !== null) {
		        icsContent.append("URI:" + event.link + "\n") // Use URL for linking
		    }
		    if (event.organizer !== null) {
		        icsContent.append("ORGANIZER;CN=" + event.organizer.name + ":mailto:" + event.organizer.email + "\n")
		    }
		    if (event.invitees !== null) {
                for (person : event.invitees) {
                    icsContent.append(generateAttendeeField(person) + "\n")
                }
            }
            if (event.recur !== null) {
                icsContent.append(generateRecurRule(event) + "\n")
            }
            if (event.reminder !== null && event.reminder != 0) {
                icsContent.append("BEGIN:VALARM\n")
                icsContent.append("TRIGGER:-PT" + event.reminder.time + "M\n")
                icsContent.append("ACTION:DISPLAY\n")
                if (event.reminder.title !== null){
                	icsContent.append("DESCRIPTION:" + event.reminder.title +"\n")
                }else{
                	icsContent.append("DESCRIPTION: Reminder about " + event.name +"\n")
                }
                
                icsContent.append("END:VALARM\n")
            }

            icsContent.append("END:VEVENT\n")
        }
        
        icsContent.append("END:VCALENDAR")
        
        // Generate the ICS file in the 'ics-gen' directory
        val fileName = "ics-gen/" + command.name + ".ics"
        fsa.generateFile(fileName, icsContent.toString)
    }
    
    def String generateAttendeeField(Person person) {
        '''ATTENDEE;CN="«person.name»":MAILTO:«person.email»'''
    }
    
    def String generateRecurRule(Event event) {
    	switch event.recur {
            case RecurRule::DAILY: "RRULE:FREQ=DAILY"
            case RecurRule::WEEKLY: "RRULE:FREQ=WEEKLY"
            case RecurRule::MONTHLY: "RRULE:FREQ=MONTHLY"
            case RecurRule::YEARLY: "RRULE:FREQ=YEARLY"
            case RecurRule::BYDAY: {
            // and mapping each WEEKDAY enum to its name (which are already the abbreviations you want).
            // Then join them with a comma for the RRULE string.
            if (event.daysOfWeek !== null) {
                val days = event.daysOfWeek.days.map[
                	day | 
				    switch (day) {
				        case WEEKDAY::MO: "MO"
				        case WEEKDAY::TU: "TU"
				        case WEEKDAY::WE: "WE"
				        case WEEKDAY::TH: "TH"
				        case WEEKDAY::FR: "FR"
				        case WEEKDAY::SA: "SA"
				        case WEEKDAY::SU: "SU"
				        default: ""
				    }
                ].join(",")
                return "RRULE:FREQ=WEEKLY;BYDAY=" + days
            } else {
                return ""
            }
        }
            default: ""
        }   
    }
    def String convertToICSTimeFormat(String userInputTime) {
        try {
            val LocalDateTime dateTime = LocalDateTime.parse(userInputTime, userInputFormatter);
            return icsFormatter.format(dateTime);
        } catch (DateTimeParseException e) {
            System.err.println("Failed to parse date time: " + userInputTime);
            return "";
        }
    }
}
